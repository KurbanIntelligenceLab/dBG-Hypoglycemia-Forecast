import numpy as np
from sklearn.metrics.pairwise import euclidean_distances

import utils.IterationUtils as Iter


class ProbabilisticModel:

    def __init__(self, k: int, probability_dict: dict, risk_threshold: float, risky_chars: set):
        """
        This class represents a Probabilistic Model generated by the de Bruijn graph.

        :param k: The length of sequence for calculating probabilities. (Same as tuple length in the de Bruijn graph)
        :type k: int

        :param probability_dict: A dictionary mapping node sequences to probabilities.
        :type probability_dict: dict

        :param risk_threshold: The threshold for classifying a sequence as risky.
        :type risk_threshold: float

        :param risky_chars: A set of characters deemed risky.
        :type risky_chars: set
        """

        self.k = k
        self.probability_dict = probability_dict
        self.risk_threshold = risk_threshold
        self.risky_chars = risky_chars

    def get_alerts(self, sequence):
        """
        Compute alert flags for a given sequence based on the probabilistic model.

        :param sequence: The sequence to analyze.
        :type sequence: list

        :return: A list of booleans indicating alerts for each item in the sequence.
        :rtype: list
        """
        alerts = [None] * len(sequence)

        for j, tuple_substr in enumerate(Iter.sliding_window(sequence, self.k - 1)):
            probability = self.get_probability(tuple_substr)
            alerts[j + self.k - 2] = probability > self.risk_threshold
        return alerts

    def get_probability(self, query: tuple):
        """
        Retrieve the probability for a given query. If the query doesn't exist in the probability dictionary,
        the method finds the most similar entry in the dictionary using euclidean distances returns its probability.

        :param query: The query for which to retrieve the probability.
        :type query: tuple

        :return: The probability of the query.
        :rtype: float
        """
        if query in self.probability_dict:
            return self.probability_dict[query]
        else:
            # Is it already in a dangerous area
            if query[-1] in self.risky_chars:
                return 1
            # Creating arrays for the query and dictionary keys
            query_array = np.array(query).reshape(1, -1)
            keys_array = np.array(list(self.probability_dict.keys()))

            # Calculating euclidean distances to find the most similar entry on the dictionary
            similarities = euclidean_distances(query_array, keys_array)

            # Finding the index of the most similar key
            most_similar_index = np.argmin(similarities)

            # Getting the most similar key
            most_similar_key = list(self.probability_dict.keys())[most_similar_index]

            return self.probability_dict[most_similar_key]
